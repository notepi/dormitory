/* soapStub.h
   Generated by gSOAP 2.8.8 from dpflow.h

Copyright(C) 2000-2012, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://target_namespace/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20808
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__noop
#define SOAP_TYPE_ns1__noop (9)
/* ns1:noop */
class SOAP_CMAC ns1__noop
{
public:
	int *a;	/* optional element of type xsd:int */
	int *b;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns1__noop */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__noop() { ns1__noop::soap_default(NULL); }
	virtual ~ns1__noop() { }
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__GuardRouteInfo
#define SOAP_TYPE_ns1__GuardRouteInfo (10)
/* ns1:GuardRouteInfo */
class SOAP_CMAC ns1__GuardRouteInfo
{
public:
	std::string *ip;	/* optional element of type xsd:string */
	std::string *netmask;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__GuardRouteInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GuardRouteInfo() { ns1__GuardRouteInfo::soap_default(NULL); }
	virtual ~ns1__GuardRouteInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Result
#define SOAP_TYPE_ns1__Result (11)
/* ns1:Result */
class SOAP_CMAC ns1__Result
{
public:
	int sum;	/* required element of type xsd:int */
	int res_USCOREcount;	/* required element of type xsd:int */
	std::vector<ns1__GuardRouteInfo * >res;	/* optional element of type ns1:GuardRouteInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__Result */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Result() { ns1__Result::soap_default(NULL); }
	virtual ~ns1__Result() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GuardAggregateConf
#define SOAP_TYPE_ns1__GuardAggregateConf (12)
/* ns1:GuardAggregateConf */
class SOAP_CMAC ns1__GuardAggregateConf
{
public:
	int aggenable;	/* required element of type xsd:int */
	int aggmasklen;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__GuardAggregateConf */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GuardAggregateConf() { ns1__GuardAggregateConf::soap_default(NULL); }
	virtual ~ns1__GuardAggregateConf() { }
};
#endif

#ifndef SOAP_TYPE__ns1__setRedirectInfoForUMC
#define SOAP_TYPE__ns1__setRedirectInfoForUMC (13)
/* ns1:setRedirectInfoForUMC */
class SOAP_CMAC _ns1__setRedirectInfoForUMC
{
public:
	std::string import_if_name;	/* required element of type xsd:string */
	std::string import_if_ip;	/* required element of type xsd:string */
	std::string import_if_mask;	/* required element of type xsd:string */
	int import_proto_type;	/* required element of type xsd:int */
	int bgp_as;	/* required element of type xsd:int */
	int bgp_nbr_as;	/* required element of type xsd:int */
	std::string bgp_nbr_ip;	/* required element of type xsd:string */
	int ospf_area;	/* required element of type xsd:int */
	std::string inject_if_name;	/* required element of type xsd:string */
	std::string inject_if_ip;	/* required element of type xsd:string */
	std::string inject_if_mask;	/* required element of type xsd:string */
	std::string inject_nexthop;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE__ns1__setRedirectInfoForUMC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__setRedirectInfoForUMC() { _ns1__setRedirectInfoForUMC::soap_default(NULL); }
	virtual ~_ns1__setRedirectInfoForUMC() { }
};
#endif

#ifndef SOAP_TYPE__ns1__setRedirectInfoForUMCResponse
#define SOAP_TYPE__ns1__setRedirectInfoForUMCResponse (14)
/* ns1:setRedirectInfoForUMCResponse */
class SOAP_CMAC _ns1__setRedirectInfoForUMCResponse
{
public:
	int *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE__ns1__setRedirectInfoForUMCResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__setRedirectInfoForUMCResponse() { _ns1__setRedirectInfoForUMCResponse::soap_default(NULL); }
	virtual ~_ns1__setRedirectInfoForUMCResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DelRedirectInfoForUMC
#define SOAP_TYPE__ns1__DelRedirectInfoForUMC (15)
/* ns1:DelRedirectInfoForUMC */
class SOAP_CMAC _ns1__DelRedirectInfoForUMC
{
public:
	std::string import_if_name;	/* required element of type xsd:string */
	std::string import_if_ip;	/* required element of type xsd:string */
	std::string import_if_mask;	/* required element of type xsd:string */
	int import_proto_type;	/* required element of type xsd:int */
	int bgp_as;	/* required element of type xsd:int */
	int bgp_nbr_as;	/* required element of type xsd:int */
	std::string bgp_nbr_ip;	/* required element of type xsd:string */
	int ospf_area;	/* required element of type xsd:int */
	std::string inject_if_name;	/* required element of type xsd:string */
	std::string inject_if_ip;	/* required element of type xsd:string */
	std::string inject_if_mask;	/* required element of type xsd:string */
	std::string inject_nexthop;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE__ns1__DelRedirectInfoForUMC */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DelRedirectInfoForUMC() { _ns1__DelRedirectInfoForUMC::soap_default(NULL); }
	virtual ~_ns1__DelRedirectInfoForUMC() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DelRedirectInfoForUMCResponse
#define SOAP_TYPE__ns1__DelRedirectInfoForUMCResponse (16)
/* ns1:DelRedirectInfoForUMCResponse */
class SOAP_CMAC _ns1__DelRedirectInfoForUMCResponse
{
public:
	int *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE__ns1__DelRedirectInfoForUMCResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DelRedirectInfoForUMCResponse() { _ns1__DelRedirectInfoForUMCResponse::soap_default(NULL); }
	virtual ~_ns1__DelRedirectInfoForUMCResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__addGuardRoute
#define SOAP_TYPE__ns1__addGuardRoute (17)
/* ns1:addGuardRoute */
class SOAP_CMAC _ns1__addGuardRoute
{
public:
	std::string destIp;	/* required element of type xsd:string */
	std::string destNetmask;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE__ns1__addGuardRoute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__addGuardRoute() { _ns1__addGuardRoute::soap_default(NULL); }
	virtual ~_ns1__addGuardRoute() { }
};
#endif

#ifndef SOAP_TYPE__ns1__addGuardRouteResponse
#define SOAP_TYPE__ns1__addGuardRouteResponse (18)
/* ns1:addGuardRouteResponse */
class SOAP_CMAC _ns1__addGuardRouteResponse
{
public:
	int *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE__ns1__addGuardRouteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__addGuardRouteResponse() { _ns1__addGuardRouteResponse::soap_default(NULL); }
	virtual ~_ns1__addGuardRouteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__removeGuardRoute
#define SOAP_TYPE__ns1__removeGuardRoute (19)
/* ns1:removeGuardRoute */
class SOAP_CMAC _ns1__removeGuardRoute
{
public:
	std::string destIp;	/* required element of type xsd:string */
	std::string destNetmask;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE__ns1__removeGuardRoute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__removeGuardRoute() { _ns1__removeGuardRoute::soap_default(NULL); }
	virtual ~_ns1__removeGuardRoute() { }
};
#endif

#ifndef SOAP_TYPE__ns1__removeGuardRouteResponse
#define SOAP_TYPE__ns1__removeGuardRouteResponse (20)
/* ns1:removeGuardRouteResponse */
class SOAP_CMAC _ns1__removeGuardRouteResponse
{
public:
	int *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE__ns1__removeGuardRouteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__removeGuardRouteResponse() { _ns1__removeGuardRouteResponse::soap_default(NULL); }
	virtual ~_ns1__removeGuardRouteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__addGuardRouteRange
#define SOAP_TYPE__ns1__addGuardRouteRange (21)
/* ns1:addGuardRouteRange */
class SOAP_CMAC _ns1__addGuardRouteRange
{
public:
	std::string startIp;	/* required element of type xsd:string */
	std::string endIp;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE__ns1__addGuardRouteRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__addGuardRouteRange() { _ns1__addGuardRouteRange::soap_default(NULL); }
	virtual ~_ns1__addGuardRouteRange() { }
};
#endif

#ifndef SOAP_TYPE__ns1__addGuardRouteRangeResponse
#define SOAP_TYPE__ns1__addGuardRouteRangeResponse (22)
/* ns1:addGuardRouteRangeResponse */
class SOAP_CMAC _ns1__addGuardRouteRangeResponse
{
public:
	int *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__ns1__addGuardRouteRangeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__addGuardRouteRangeResponse() { _ns1__addGuardRouteRangeResponse::soap_default(NULL); }
	virtual ~_ns1__addGuardRouteRangeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__removeGuardRouteRange
#define SOAP_TYPE__ns1__removeGuardRouteRange (23)
/* ns1:removeGuardRouteRange */
class SOAP_CMAC _ns1__removeGuardRouteRange
{
public:
	std::string startIp;	/* required element of type xsd:string */
	std::string endIp;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__ns1__removeGuardRouteRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__removeGuardRouteRange() { _ns1__removeGuardRouteRange::soap_default(NULL); }
	virtual ~_ns1__removeGuardRouteRange() { }
};
#endif

#ifndef SOAP_TYPE__ns1__removeGuardRouteRangeResponse
#define SOAP_TYPE__ns1__removeGuardRouteRangeResponse (24)
/* ns1:removeGuardRouteRangeResponse */
class SOAP_CMAC _ns1__removeGuardRouteRangeResponse
{
public:
	int *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__ns1__removeGuardRouteRangeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__removeGuardRouteRangeResponse() { _ns1__removeGuardRouteRangeResponse::soap_default(NULL); }
	virtual ~_ns1__removeGuardRouteRangeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__modGuardRoute
#define SOAP_TYPE__ns1__modGuardRoute (25)
/* ns1:modGuardRoute */
class SOAP_CMAC _ns1__modGuardRoute
{
public:
	std::string delRoute;	/* required element of type xsd:string */
	std::string addRoute;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE__ns1__modGuardRoute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__modGuardRoute() { _ns1__modGuardRoute::soap_default(NULL); }
	virtual ~_ns1__modGuardRoute() { }
};
#endif

#ifndef SOAP_TYPE__ns1__modGuardRouteResponse
#define SOAP_TYPE__ns1__modGuardRouteResponse (26)
/* ns1:modGuardRouteResponse */
class SOAP_CMAC _ns1__modGuardRouteResponse
{
public:
	int *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE__ns1__modGuardRouteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__modGuardRouteResponse() { _ns1__modGuardRouteResponse::soap_default(NULL); }
	virtual ~_ns1__modGuardRouteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getGuardRouteInfo
#define SOAP_TYPE__ns1__getGuardRouteInfo (27)
/* ns1:getGuardRouteInfo */
class SOAP_CMAC _ns1__getGuardRouteInfo
{
public:
	int count;	/* required element of type xsd:int */
	int offset;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE__ns1__getGuardRouteInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getGuardRouteInfo() { _ns1__getGuardRouteInfo::soap_default(NULL); }
	virtual ~_ns1__getGuardRouteInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getGuardRouteInfoResponse
#define SOAP_TYPE__ns1__getGuardRouteInfoResponse (28)
/* ns1:getGuardRouteInfoResponse */
class SOAP_CMAC _ns1__getGuardRouteInfoResponse
{
public:
	ns1__Result *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:Result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE__ns1__getGuardRouteInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getGuardRouteInfoResponse() { _ns1__getGuardRouteInfoResponse::soap_default(NULL); }
	virtual ~_ns1__getGuardRouteInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__setGuardConfigFinish
#define SOAP_TYPE__ns1__setGuardConfigFinish (29)
/* ns1:setGuardConfigFinish */
class SOAP_CMAC _ns1__setGuardConfigFinish
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE__ns1__setGuardConfigFinish */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__setGuardConfigFinish() { _ns1__setGuardConfigFinish::soap_default(NULL); }
	virtual ~_ns1__setGuardConfigFinish() { }
};
#endif

#ifndef SOAP_TYPE__ns1__setGuardConfigFinishResponse
#define SOAP_TYPE__ns1__setGuardConfigFinishResponse (30)
/* ns1:setGuardConfigFinishResponse */
class SOAP_CMAC _ns1__setGuardConfigFinishResponse
{
public:
	int *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE__ns1__setGuardConfigFinishResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__setGuardConfigFinishResponse() { _ns1__setGuardConfigFinishResponse::soap_default(NULL); }
	virtual ~_ns1__setGuardConfigFinishResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getGuardAggregateRouteInfo
#define SOAP_TYPE__ns1__getGuardAggregateRouteInfo (31)
/* ns1:getGuardAggregateRouteInfo */
class SOAP_CMAC _ns1__getGuardAggregateRouteInfo
{
public:
	int count;	/* required element of type xsd:int */
	int offset;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE__ns1__getGuardAggregateRouteInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getGuardAggregateRouteInfo() { _ns1__getGuardAggregateRouteInfo::soap_default(NULL); }
	virtual ~_ns1__getGuardAggregateRouteInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns1__setGuardAggEnable
#define SOAP_TYPE__ns1__setGuardAggEnable (32)
/* ns1:setGuardAggEnable */
class SOAP_CMAC _ns1__setGuardAggEnable
{
public:
	int enableagg;	/* required element of type xsd:int */
	int aggmask;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE__ns1__setGuardAggEnable */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__setGuardAggEnable() { _ns1__setGuardAggEnable::soap_default(NULL); }
	virtual ~_ns1__setGuardAggEnable() { }
};
#endif

#ifndef SOAP_TYPE__ns1__setGuardAggEnableResponse
#define SOAP_TYPE__ns1__setGuardAggEnableResponse (33)
/* ns1:setGuardAggEnableResponse */
class SOAP_CMAC _ns1__setGuardAggEnableResponse
{
public:
	int *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE__ns1__setGuardAggEnableResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__setGuardAggEnableResponse() { _ns1__setGuardAggEnableResponse::soap_default(NULL); }
	virtual ~_ns1__setGuardAggEnableResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__getGuardAggregateConf
#define SOAP_TYPE__ns1__getGuardAggregateConf (34)
/* ns1:getGuardAggregateConf */
class SOAP_CMAC _ns1__getGuardAggregateConf
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE__ns1__getGuardAggregateConf */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__getGuardAggregateConf() { _ns1__getGuardAggregateConf::soap_default(NULL); }
	virtual ~_ns1__getGuardAggregateConf() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GuardAggregateConfResponse
#define SOAP_TYPE__ns1__GuardAggregateConfResponse (35)
/* ns1:GuardAggregateConfResponse */
class SOAP_CMAC _ns1__GuardAggregateConfResponse
{
public:
	ns1__GuardAggregateConf *ret;	/* required element of type ns1:GuardAggregateConf */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE__ns1__GuardAggregateConfResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GuardAggregateConfResponse() { _ns1__GuardAggregateConfResponse::soap_default(NULL); }
	virtual ~_ns1__GuardAggregateConfResponse() { }
};
#endif

#ifndef SOAP_TYPE___ns1__setRedirectInfoForUMC
#define SOAP_TYPE___ns1__setRedirectInfoForUMC (47)
/* Operation wrapper: */
struct __ns1__setRedirectInfoForUMC
{
public:
	_ns1__setRedirectInfoForUMC *ns1__setRedirectInfoForUMC;	/* optional element of type ns1:setRedirectInfoForUMC */
};
#endif

#ifndef SOAP_TYPE___ns1__DelRedirectInfoForUMC
#define SOAP_TYPE___ns1__DelRedirectInfoForUMC (51)
/* Operation wrapper: */
struct __ns1__DelRedirectInfoForUMC
{
public:
	_ns1__DelRedirectInfoForUMC *ns1__DelRedirectInfoForUMC;	/* optional element of type ns1:DelRedirectInfoForUMC */
};
#endif

#ifndef SOAP_TYPE___ns1__addGuardRoute
#define SOAP_TYPE___ns1__addGuardRoute (55)
/* Operation wrapper: */
struct __ns1__addGuardRoute
{
public:
	_ns1__addGuardRoute *ns1__addGuardRoute;	/* optional element of type ns1:addGuardRoute */
};
#endif

#ifndef SOAP_TYPE___ns1__removeGuardRoute
#define SOAP_TYPE___ns1__removeGuardRoute (59)
/* Operation wrapper: */
struct __ns1__removeGuardRoute
{
public:
	_ns1__removeGuardRoute *ns1__removeGuardRoute;	/* optional element of type ns1:removeGuardRoute */
};
#endif

#ifndef SOAP_TYPE___ns1__addGuardRouteRange
#define SOAP_TYPE___ns1__addGuardRouteRange (63)
/* Operation wrapper: */
struct __ns1__addGuardRouteRange
{
public:
	_ns1__addGuardRouteRange *ns1__addGuardRouteRange;	/* optional element of type ns1:addGuardRouteRange */
};
#endif

#ifndef SOAP_TYPE___ns1__removeGuardRouteRange
#define SOAP_TYPE___ns1__removeGuardRouteRange (67)
/* Operation wrapper: */
struct __ns1__removeGuardRouteRange
{
public:
	_ns1__removeGuardRouteRange *ns1__removeGuardRouteRange;	/* optional element of type ns1:removeGuardRouteRange */
};
#endif

#ifndef SOAP_TYPE___ns1__modGuardRoute
#define SOAP_TYPE___ns1__modGuardRoute (71)
/* Operation wrapper: */
struct __ns1__modGuardRoute
{
public:
	_ns1__modGuardRoute *ns1__modGuardRoute;	/* optional element of type ns1:modGuardRoute */
};
#endif

#ifndef SOAP_TYPE___ns1__getGuardRouteInfo
#define SOAP_TYPE___ns1__getGuardRouteInfo (75)
/* Operation wrapper: */
struct __ns1__getGuardRouteInfo
{
public:
	_ns1__getGuardRouteInfo *ns1__getGuardRouteInfo;	/* optional element of type ns1:getGuardRouteInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__setGuardConfigFinish
#define SOAP_TYPE___ns1__setGuardConfigFinish (79)
/* Operation wrapper: */
struct __ns1__setGuardConfigFinish
{
public:
	_ns1__setGuardConfigFinish *ns1__setGuardConfigFinish;	/* optional element of type ns1:setGuardConfigFinish */
};
#endif

#ifndef SOAP_TYPE___ns1__getGuardAggregateRouteInfo
#define SOAP_TYPE___ns1__getGuardAggregateRouteInfo (82)
/* Operation wrapper: */
struct __ns1__getGuardAggregateRouteInfo
{
public:
	_ns1__getGuardAggregateRouteInfo *ns1__getGuardAggregateRouteInfo;	/* optional element of type ns1:getGuardAggregateRouteInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__setGuardAggEnable
#define SOAP_TYPE___ns1__setGuardAggEnable (86)
/* Operation wrapper: */
struct __ns1__setGuardAggEnable
{
public:
	_ns1__setGuardAggEnable *ns1__setGuardAggEnable;	/* optional element of type ns1:setGuardAggEnable */
};
#endif

#ifndef SOAP_TYPE___ns1__getGuardAggregateConfResponse
#define SOAP_TYPE___ns1__getGuardAggregateConfResponse (89)
/* Operation wrapper: */
struct __ns1__getGuardAggregateConfResponse
{
public:
	char *wsdl__GuardAggregateConfResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type wsdl:GuardAggregateConfResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__getGuardAggregateConf
#define SOAP_TYPE___ns1__getGuardAggregateConf (90)
/* Operation wrapper: */
struct __ns1__getGuardAggregateConf
{
public:
	_ns1__getGuardAggregateConf *ns1__getGuardAggregateConf;	/* optional element of type ns1:getGuardAggregateConf */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (91)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (92)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (94)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (97)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (98)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE__wsdl__GuardAggregateConfResponse
#define SOAP_TYPE__wsdl__GuardAggregateConfResponse (8)
typedef char *_wsdl__GuardAggregateConfResponse;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setRedirectInfoForUMC(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__setRedirectInfoForUMC *ns1__setRedirectInfoForUMC, _ns1__setRedirectInfoForUMCResponse *ns1__setRedirectInfoForUMCResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__DelRedirectInfoForUMC(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__DelRedirectInfoForUMC *ns1__DelRedirectInfoForUMC, _ns1__DelRedirectInfoForUMCResponse *ns1__DelRedirectInfoForUMCResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__addGuardRoute(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__addGuardRoute *ns1__addGuardRoute, _ns1__addGuardRouteResponse *ns1__addGuardRouteResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeGuardRoute(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__removeGuardRoute *ns1__removeGuardRoute, _ns1__removeGuardRouteResponse *ns1__removeGuardRouteResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__addGuardRouteRange(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__addGuardRouteRange *ns1__addGuardRouteRange, _ns1__addGuardRouteRangeResponse *ns1__addGuardRouteRangeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeGuardRouteRange(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__removeGuardRouteRange *ns1__removeGuardRouteRange, _ns1__removeGuardRouteRangeResponse *ns1__removeGuardRouteRangeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__modGuardRoute(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__modGuardRoute *ns1__modGuardRoute, _ns1__modGuardRouteResponse *ns1__modGuardRouteResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getGuardRouteInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getGuardRouteInfo *ns1__getGuardRouteInfo, _ns1__getGuardRouteInfoResponse *ns1__getGuardRouteInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setGuardConfigFinish(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__setGuardConfigFinish *ns1__setGuardConfigFinish, _ns1__setGuardConfigFinishResponse *ns1__setGuardConfigFinishResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getGuardAggregateRouteInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getGuardAggregateRouteInfo *ns1__getGuardAggregateRouteInfo, _ns1__getGuardRouteInfoResponse *ns1__getGuardRouteInfoResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setGuardAggEnable(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__setGuardAggEnable *ns1__setGuardAggEnable, _ns1__setGuardAggEnableResponse *ns1__setGuardAggEnableResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getGuardAggregateConf(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__getGuardAggregateConf *ns1__getGuardAggregateConf, char *wsdl__GuardAggregateConfResponse);

#endif

/* End of soapStub.h */
